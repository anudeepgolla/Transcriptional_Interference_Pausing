import pandas as pd
import numpy as np


"""

sequence_data_processor.py : take seq data and encode with onehot, ordinal, k-gram and do other normalization/processing

"""

# load sequence data and create indexes such that each position in
# pause and context as its own column for A, C, G, T
def indexify():
    # load data
    df = pd.read_csv('data/sequence_ds_v1.csv')
    print(df.shape)

    # Sequence Indexing
    # get strings of all pause sequences
    ps_df = list(df['pause_seq'].str)

    # add these string representations into new columns based on pause seq
    for i in range(len(ps_df)):
        df['pause_seq_{}'.format(i)] = ps_df[i]

    # get strings of all context sequences
    pc_df = list(df['pause_context'].str)

    # add these string representations into new columns based on context seq
    for i in range(len(pc_df)):
        df['pause_context_{}'.format(i)] = pc_df[i]

    print(df.shape)
    # save data in csv
    df.to_csv('data/sequence_ds_indexed_v2.csv')


# load sequence data and encode sequences into ordinal encoding
def ordinal_encoding():
    # load data (indexed version)
    df = pd.read_csv('data/sequence_ds_indexed_v2.csv')
    print(df.shape)

    # Ordinal Encoding
    ordinal_cols = []
    for c in df.columns:
        # choose columns that are ony associated with the new indexed columns generated by indexify()
        if c[:10] == 'pause_seq_' or c[:14] == 'pause_context_':
            ordinal_cols.append(c)

    # map between string bp to ordinal value
    ordinal_mapper = {'A': 0.25, 'C': 0.50, 'G': 0.75, 'T': 1.00}

    # convert all string data into ordinal data using mapper
    for i in range(df.shape[0]):
        for c in ordinal_cols:
            df.loc[i, c] = ordinal_mapper[df.loc[i, c]]

        if (i+1) % 100 == 0:
            print('Step {:5}/{:5} = {:2}%'.format(i+1, 68893, (i+1)*100//68893))

    print(df.head(5))

    # save data in csv
    df.to_csv('data/sequence_ds_ordinal_v3.csv')
    print('Saved!')


# load sequence data and encode sequences into onehot encoding
def onehot_encoding():
    # load index data
    df = pd.read_csv('../data/seq/sequence_ds_indexed_v2.csv')
    print(df.shape)

    # One-Hot Encoding
    onehot_cols = []
    for c in df.columns:
        # choose columns that are ony associated with the new indexed columns generated by indexify()
        if c[:10] == 'pause_seq_' or c[:14] == 'pause_context_':
            onehot_cols.append(c)

    # for c in df.columns:
    #     if c not in onehot_cols:
    #         print(c)

    # categorically encode all the onehot colums
    dummies = pd.get_dummies(df, columns=onehot_cols, prefix=onehot_cols)
    # df = pd.concat([df, dummies], axis=1)
    # print(df.shape)

    print(dummies.shape)
    print(dummies.columns)
    # for c in dummies.columns[:]:
    #     print(c)
    #

    # save just categorical columns (dummies) in csv
    dummies.to_csv('data/sequence_ds_onehot_v1.csv')
    print('Saved!')


# load sequence data and encode sequences into kmers/k-gram encoding
def kmers_encoding():
    # load strict sequence data
    df = pd.read_csv('../data/seq/sequence_ds_v1.csv')
    print(df.shape)

    # KMers Encoding
    # method gets lsit of kMers encodings of a long sequence
    def getKmers(sequence, size):
        # list of size length substrings of longer string
        return [sequence[x:x+size].lower() for x in range(len(sequence) - size + 1)]

    # set kmer size and add new columns of pause encodings and context encodings
    kmer_size = 12
    df['pause_seq_kmers'] = np.nan
    df['pause_context_kmers'] = np.nan

    # iterate through all samples
    for i in range(df.shape[0]):
        # for each, concatentate all kmers substrings with spaces so each sequence has one long sequence
        # for both pause and context sequences
        df.loc[i, 'pause_seq_kmers'] = ' '.join(getKmers(df.loc[i, 'pause_seq'], size=kmer_size))
        df.loc[i, 'pause_context_kmers'] = ' '.join(getKmers(df.loc[i, 'pause_context'], size=kmer_size))

        # print progress
        if (i + 1) % 100 == 0:
            print('Step {:5}/{:5} = {:2}%'.format(i+1, 68893, (i+1)*100//68893))

    print(df.shape)
    print(df.head(10))

    # save data to csv
    df.to_csv('../data/seq/sequence_ds_kmers_12_v1.csv')
